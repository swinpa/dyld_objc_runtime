#设计模式相关

###六大设计原则
* 单一职责原则
	
	定义：就一个类而言， 应该仅有一个引起它变化的原因。（一个类只负责一件事）
	
	比如CALayer，UIView。CALayer只负责页面显示，UIView负责页面的事件传递与响应
	

* 开闭原则

	定义：类、模块、函数等应该是可以拓展的，但是不可修改。（修改关闭，扩展开放）
	
* 接口隔离原则

	定义：一个类对另一个类的依赖应该建立在最小的接口上。（使用多个专门的协议而不是一个臃肿庞大的协议）
	
	比如UITableView 的Delegate 与DataSource，Delegate负责UITableView的事件回调，而DataSource负责UITableView的数据源
	
* 依赖倒置原则

	定义：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。（抽象不应该依赖于具体实现，具体实现可以依赖于抽象）
	
	上层业务依赖于抽象定义的接口而不关心他内部的具体实现（比如数据层定义了增删改查的接口，上层依赖于这些接口，而不关心数据层底层到底是用数据库还是文件实现的）
	
* 里斯替换原则

	定义：所有引用基类的地方必须能透明地使用其子类的对象。（父类可以被子类无缝替换，且原有功能不受影响）
	
	KVO实现原理就是遵守了这一原则，

* 迪米特法则
    
    迪米特法则(Law of Demeter )又叫做最少知识原则，也就是说，一个对象应当对其他对象尽可能少的了解。不和陌生人说话。英文简写为: LoD。

    迪米特法则的目的在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。

    迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。

###设计模式
[参考文章1](https://github.com/YouXianMing/iOS-Design-Patterns)  [参考文章2](https://github.com/songshaopeng/iOS-Design-Patterns)

* 责任链

	######定义：
		在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。
		请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的
		客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响
		客户端的情况下动态地重新组织和分配责任。
	
	######项目中的例子：
		1，UI事件传递
		
		2，付费功能点 -- [订阅] --> [激励视频] --> [app 评论好评]， 只要该链上任何一个功能做了，
		都可以体验付费的功能
	
* 桥接模式

	######定义
		桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，
		它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。这种模式涉及到一个作为桥接的接口，
		使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

	#####如何使用桥接模式？
	* 在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。
 实现系统可能有多个角度分类，每一种角度都可能变化。
 把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

	#####桥接模式的优缺点？
	* 优点 ：抽象和实现的分离、优秀的扩展能力、实现细节对客户透明。
	* 缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

	#####[实际项目中的使用场景？]
		Cutart图片编辑中的滤镜处理
		滤镜分艺术滤镜，lookup滤镜，线上渲染滤镜，磨皮滤镜，美颜滤镜等，后续可能还会加其他滤镜
		图片中有一个抽象的滤镜属性，在图片需要渲染时，调用该属性执行渲染即可对图片进行操作
		具体是要怎么渲染，由具体的滤镜实现，
		
		@protocol Filter <NSObject>
		- (void)didRender;
		@end
		
		@interface LookupFilter : NSObject<Filter>
		@end
		@implementation LookupFilter
		- (void)didRender {}
		@end

		@interface ArtisticFilter : NSObject<Filter>
		@end
		@implementation ArtisticFilter
		- (void)didRender {}
		@end

		@interface OnlineFilter : NSObject<Filter>
		@end
		@implementation OnlineFilter
		- (void)didRender {}
		@end
		
		@interface CTUIImage : UIImage
		@property (nonatomic, strong) id<Filter>  filter;
		- (void)excuteFilter;
		@end
		@implementation CTUIImage
		- (void)excuteFilter {
		    [self.filter didRender];
		}
		@end

* 适配器模式
	
	#####何为适配器模式?
	
	适配器模式将一个类的接口适配成用户所期待的。一个适配器通常允许因为接口不兼容而不能一起工作的类能够在一起工作，
	做法是将类自己的接口包裹在一个已存在的类中。

	#####[如何使用适配器模式？]

	* 当你想使用一个已经存在的类，而它的接口不符合你的需求；
	* 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；
	* 你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它的父亲接口。

	#####[适配器模式的优缺点？]

	* 优点：降低数据层和视图层（对象）的耦合度，使之使用更加广泛，适应复杂多变的变化。
	* 缺点：降低了可读性，代码量增加，对于不理解这种模式的人来说比较难看懂。

	#####[实际项目中的使用场景？]
	
	```
	在cutart项目中，编辑页里面的抠图列表跟滤镜列表视图层是一样的，但是model是不一样的，那么这种情况下
	就可以使用适配模式，让视图层与适配器通信，视图需要的数据通过适配器获取
	```

	### <桥接模式> 与 <适配模式> 的区别，[参考文章](https://blog.csdn.net/xiefangjin/article/details/51056411)
	
	```
	共同点
	桥接和适配器都是让两个东西配合工作

	不同点
	
	```

* 单例模式
* 策略模式
	
	####定义
		1. 把解决相同问题的算法抽象成策略(相同问题指的是输入参数相同,但根据算法不同输出参数会有差异)
		2. 策略被封装在对象之中(是对象内容的一部分),策略改变的是对象的内容.如果从外部扩展了对象的行为,就不叫策略模式,而是装饰模式.
		3. 策略模式可以简化复杂的判断逻辑(if - else)
		4. 如果对面向对象基本原理以及设计模式基本原理不熟悉,本教程会变得难以理解.


* 命令模式
	######定义
		将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，
		以及支持可撤销操作。
	######项目中的例子：
		1，NSInvocation
		
		2，图片编辑操作的历史记录
		  【抠图】->【滤镜】->【调整饱和度】->【调整色温】
		   每一步的操作放到一个栈中，如果需要撤销，则对栈进行出栈即可，将出栈的操作加入到一个队列中，
		   如果需要恢复，则从队列中获取，重新入栈即可
		   

* 装饰器模式

    允许向一个现有的对象添加新的功能，同时又不改变其结构


##MVC & MVVM

[IOS项目架构](https://blog.csdn.net/zhanglei5415/article/details/123967742)

###写在前面
* 关于MVC&MVVM的一点思考

* 一个应用，一个页面，无非就是展示信息(数据)，响应用户操作进行相应的逻辑处理
* 那么展示信息的载体当然就是View咯，需要展示的信息数据就是Model咯。
* 如果View，Model之间没有隔离，他们相互持有当然也可以，但是这样他们就成了1对1的关系，View就不能放到别的页面上，显示别的Model的数据了。
* 为了能让View，Model二者都能够被复用到其他页面上，所以他们之间不能相互依赖，相互引用持有。因此就出现了Controller作为中介者。当View展示在屏幕上时，通过中介者Controller将展示内容设置给View，另外当View监听到有用户交互事件时，她通过delegate，或者target-action 通知Controller做相应的处理逻辑。如果交互事件是需要更新Model时，也是通过Controller去更新。当然Controller可以通过KVO的方式监听到Model变化时，如果需要将变化更新在页面上时，也是通过Controller将变更的数据设置到View上。
* 当页面页面越来越复杂，展示的信息越来越多，响应用户事件越来越多的时候，Controller不但要处理用户繁杂的交互事件，同时可能需要对需要展示的数据进行最终的处理才能给View展示（比如将时间戳转成容易理解的时间格式，将图片链接转成图片等等）。此时的Controller了会越来越臃肿切不好维护
* 为了减轻Controller的负担就出现了ViewModel
* Controller 负责将ViewModel与View进行绑定，绑定的目的是将View需要展示的内容直接由ViewModel提供，而且提供的是直接能展示的，不需要再经过转换的。当数据有更新时能直接通知View更新，ViewModel负责原生数据的加载与解析
* 所以Controller的职责就清晰很多，后续如果需要新增展示的数据，只需要新增一条绑定，其他事情不用他管，
* 所以最终Controller的职责只包括两部分：
	
	1. 处理用户交互事件
	2. ViewModel与View的绑定
* ViewModel还有一层职责就是保存View的中间状态
	
	```
	比如一个我们有一个蚂蚁雅黑功能，中间状态包括人脸识别，渲染，人脸识别跟渲染这两个阶段的loading
	不太一样，当开始该功能时，从当前状态开始展示loading，比如起初是从人脸识别到渲染，假如渲染失败，
	从新来时，则可以调过人脸识别，直接从渲染开始
	```
	
###如何回答项目架构问题
1. 我们的项目架构，从数据流向来分的话，由顶到低是分为：展示层->数据层->网络层
	展示层负责展示
	数据层负责向展示层提供数据，同时需要处理缓存，我们使用的是文件缓存，因为我们首页的数据一次性拉完回来的，合适用文件
	
2. 从功能划分的话：业务层->通用业务层->基础层
	
	业务层：
		
		负责业务开发，如首页展示，图片编辑页
	
	通用业务层：
		
		各APP间通用UI如网络加载的loading，图片渲染的loading（依赖于masonry），还有其他alert提示弹窗，
		还有通用模块如，打点模块（依赖网络模块），买量模块（依赖网络模块），订阅模块
	
	基础模块：
		
		网络库（AFNetworking），UI约束库（masonry），日志

###MVC

[参考1](https://www.jianshu.com/p/d39a5eee48d7)

[参考2](https://mp.weixin.qq.com/s/ilMUx7EldPhLvtQVTnGELA)
[iOS 项目架构模式](http://www.360doc.com/content/22/0102/12/76879670_1011512287.shtml)

* View 视图，负责界面的元素的展示，响应用户事件，通过代理(delegate)或者target-action 通知Controller(Controller或者更新model，或者执行业务跳转)
* Model发生变化，有更新时，通过KVO，Notification 通知 Controller（Controller更新View）
*  C 控制器，管理View的声明周期及子view的生成和组装，负责Model和View之间的通信。负责业务处理，当Model更新时更新View状态，当View有事件时，要么更新Model，要么有业务跳转

###MVVM

##模块化方案
1. MGJRouter
2. CTMediator
3. BeeHive

####MGJRouter

* 优点
	
	1. URL 本身是一种跨多端的通用协议。使用路由URL统跳方案的优势是动态性及多端统一 
* 缺点

	1. 缺点是能处理的交互场景偏简单。所以一般更适用于简单 UI 页面跳转。一些复杂操作和数据传输，不好实现

####CTMediator

* 这种方案的优势是调用简单方便，代码自动补全和编译时检查都仍然有效。 劣势是 category 存在重名覆盖的风险，需要通过开发规范以及一些检查机制来规避。同时 Mediator 只是收敛了 hardcode, 并未消除 hardcode, 仍然对开发效率有一定影响。
	
* 理解
	1. CTMediator 是通过OC的反射机制(Runtime机制)（NSClassFromString(),NSSelectorFromString()）来获取模块对象从而达到模块间解耦的目的。因为使用的硬编码的字符串，所以会存在一定的问题
*  优化
	1. 通过__attribute((used, section("__DATA,"#sectname" ")))方式，将组件进行自注册，当想使用组件时，去指定的section获取使用，如果获取不到，说明组件已经废弃了
	
####BeeHive
* 
1. 编译期间，通过__attribute((used, section("__DATA,"#sectname" ")))方式，将遵守协议的模块（UIViewController）已键值的方式写入到指定的section中（{ "HomeServiceProtocol" : "BHViewController"}类似这样写入到section中）
2. 通过dyld提供的方法 _dyld_register_func_for_add_image(dyld_callback);注册一个image加载完成的回调方法dyld_callback，当image加载完成时，回调该方法，然后在该方法中获取指定的section，获取到协议与模块的数据（协议名，UIViewController类名），然后将其注册到BHServiceManager中（通过[[BHServiceManager sharedManager] registerService:NSProtocolFromString(protocol) implClass:NSClassFromString(clsName)];），就是以协议为key，UIViewController为value，存放在字典中

	```
	allServicesDict = {
		"HomeServiceProtocol" : "BHViewController",
		"TradeServiceProtocol" : "BHTradeViewController"
	}
	```
	####上面相当于静态注册，同时也支持动态注册
	* 动态注册在+load方法中调用[BeeHive registerDynamicModule:[self class]];方法，在该方法的过程中，通过一定逻辑执行到[[BHServiceManager sharedManager] registerService:NSProtocolFromString(protocol) implClass:NSClassFromString(clsName)];进行注册
	
3. 使用其他模块时，通过[[BeeHive shareInstance] createService:@protocol(TradeServiceProtocol)]; 方式获取模块对象
	
		其实就是根据传进来的协议名，从第二步注册的字典中找到对应的模块名，然后进行创建

* 这样，虽然模块间没有直接引入，但在获取模块对象时需要传入协议，同样需要引入协议的头文件，相当于同样还是需要引入依赖
	

##CocoaPods

![参考文章](https://juejin.cn/post/6844903618789769230)

* 解析 Podfile 中的依赖
	* 根据podfile 中的source，下载或更新source中所有的AFNetworking.podspec(描述了组件的信息，下载地址，版本信息，依赖哪些代码等等)
	* 
* 下载依赖

	* 根据podspec 中的描述信息，下载源代码

* 创建 Pods.xcodeproj 工程

	* 生成 Pods.xcodeproj 工程

	* 将依赖中的文件加入工程
	
	* 将依赖中的 Library 加入工程
	
	* 设置目标依赖（Target Dependencies）

* 集成 workspace

	*创建一个 workspace，获取所有要集成的 Target 实例，将其加入到主工程project.pbxproj中
	
	
#### Other
* .cocoapods/repos 下有各个source的源，源上存储了所有的第三方库的描述文件（也就是podspec文件）
* 在pod install, update 的时候会去到这个目录下找到第三方库对应的描述文件，然后根据描述文件上的信息，下载对应的第三方库
* 如果本地没有指定版本的podspec 会根据情况下更新这个源（根据podfile 中所描述的source地址去下载）

### 如何回答最有挑战的项目？也就是工作中的难点

* 毕竟这是一个由自己主导去做的一个项目，所以会花更多的心思在上面

* 所以我在搭建这个项目的时候，根据我对以往其他项目的了解，在这个项目上我考虑更多的时候是项目的延展性，以及功能的拓展性

* 在更换了Prisma 的SDK后，我们后台提供的模型渲染出来的效果，比之前差了很多，那时候我想自己线上找一些效果好的模型，或者训练，其实那时候那时候怎么去训练模型这些资料已经找的差不多了，也有一些现有的效果好的模型，我提供给我们的推广看，都觉得效果不错，后续由于另外的一些因素吧。转去了别的部门，所以这个事情就没后续了

* 一个项目从0-1本身就具有一定的挑战性，特别是作为主导这个项目的开发人员来说，因为这需要对整个项目的需求都要了解，
* 需要对需求进行合理的拆分（按功能拆分，大功能拆分成小功能），分配到每个开发同学都要合理（自己挑选），还要
* 及时了解开发进度以及开发过程中遇到的难点

* 在搭建项目的时候还要考虑功能的扩展性（扩展性包括从一个APP延伸出另一个APP（就比如从我们的go输入法又做了avatar输入法，wonderkey 输入法）），这就需要将一些通用的东西抽出来，比如一些网络加载loading动画，alert弹框，订阅模块，还有图片选择器，买量，打点等等模块，将这些通用的东西抽出来可以方便我们在开辟另一个相机项目时使用，可以提高效率

* 还需要考虑功能性的拓展，比如一个滤镜，前期他可能只是风格化滤镜跟GPUImage的lookup 滤镜，后期可能会增加其他效果的滤镜，或者增加线上渲染的滤镜（线上渲染的滤镜可以处理比较大的图片，因为在手机上内存小，推理消耗的内存大）

* 为了可以加快进度，一些类似的页面就需要考虑抽出来做一份，比如我们的编辑页中的抠图模板列表，跟滤镜列表，他们展示是一样的，只是数据源不一样，所以展示就做一份底层通过适配器对数据进行了适配

1. 项目从0-1的搭建，如何分层，
	```
	如何将抠图模板跟滤镜进行共性抽离，如何将滤镜功能做到可扩展？，如何将启动做到按循序执行（权限弹框，广告，订阅页，跳转对应页面；这可以考虑使用链式模式套）
	```
2. 需求如何分配：
	
	按功能点拆分，大功能点又拆分成小功能点，然后根据人员能力进行分配（一般让他们自己挑选做哪些模块）
	
3. 如何管控进度
	
	对功能点进行时间评估，评估精度小的到小时，大到按天算，每个功能点会有提测时间，后续会根据这个评估
	的时间表进行落实，每周周一微信上开个讨论组进行语音沟通，相互了解大家的进度情况，遇到的难点，以及
	相应的资源（一般是UI资源）有没有及时拿到



