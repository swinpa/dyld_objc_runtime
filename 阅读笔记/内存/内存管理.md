#内存管理

[iOS内存分配与五大区域](https://blog.csdn.net/m0_52192682/article/details/125779609)

1. object-c 申请内存过程（调用栈）

	```
	[NSObject alloc]
	
	1.
	alloc -> _objc_rootAlloc -> callAlloc -> _objc_rootAllocWithZone -> _class_createInstanceFromZone
	在_objc_rootAllocWithZone前面的调用栈都是直接调用下层接口，不做任何逻辑处理
	在_class_createInstanceFromZone 会通过instanceSize接口获取当前对象需要申请多大的内存空间
	instanceSize 大小 通过获取类的 ro()->instanceSize 字段得到，然后进行字对齐得到最终需要申请的内存大小
	
	2.
	通过calloc(1, size)从默认的zone 中申请内存，这里申请得到的只是虚拟内存，真正的物理内存只有在使用这
	虚拟内存时底层才进行虚拟内存到真实内存的映射，所以这里calloc(1, size)返回的内存地址其实是虚拟的内存
	地址
	
	```
	```
	2. 编译期间，类都是以_class_t结构体存在，通过以下方式(__attribute__)将类信息保存到mach-o的数据段中，其中的
	struct _class_ro_t *ro则是类内存布局相关信息，其中包含了对象所需内存大小信息字段
	struct _class_t {
		struct _class_t *isa;
		struct _class_t *superclass;
		void *cache;
		void *vtable;
		struct _class_ro_t *ro;
	};
	extern "C" __declspec(dllexport) struct _class_t OBJC_CLASS_$_Person __attribute__ ((used, section ("__DATA,__objc_data"))) = {
		0, // &OBJC_METACLASS_$_Person,
		0, // &OBJC_CLASS_$_NSObject,
		0, // (void *)&_objc_empty_cache,
		0, // unused, was (void *)&_objc_empty_vtable,
		&_OBJC_CLASS_RO_$_Person,
	};
	
	--------------------------------------------------------------------------------------------------
	_class_ro_t 描述了类内存布局相关信息，包含了对象所需内存大小信息字段
	struct _class_ro_t {
		unsigned int flags;
	    //-----------确定了成员变量的地址空间----------------
		unsigned int instanceStart;
		unsigned int instanceSize;
	    //---------------------------
		const unsigned char *ivarLayout;
		const char *name;
		const struct _method_list_t *baseMethods;
		const struct _objc_protocol_list *baseProtocols;
		const struct _ivar_list_t *ivars;
		const unsigned char *weakIvarLayout;
		const struct _prop_list_t *properties;
	};

	_class_ro_t通过以下方式(__attribute__)将类信息保存到mach-o的数据段中
	--------------------------------------------------------------------------------------------------
	
	static struct _class_ro_t _OBJC_CLASS_RO_$_Person __attribute__ ((used, section ("__DATA,__objc_const"))) = {
		0,
	    __OFFSETOFIVAR__(struct Person, father_var_loves),
	    /*
	     sizeof() 是一个运算符，并不是一个函数。sizeof() 传进来的是类型，用来计算这个类型占多大内存，这个在 编译器编译阶段 
	     就会确定大小并直接转化成 8 、16 、24 这样的常数，而不是在运行时计算。参数可以是数组、指针、类型、对象、结构体、函数等。
	     */
	    sizeof(struct Person_IMPL),
		0, 
		"Person",
		(const struct _method_list_t *)&_OBJC_$_INSTANCE_METHODS_Person,
		0, 
		(const struct _ivar_list_t *)&_OBJC_$_INSTANCE_VARIABLES_Person,
		0, 
		(const struct _prop_list_t *)&_OBJC_$_PROP_LIST_Person,
	};

	```
	```
	从上面可以看出ro()->instanceSize大小首次确定是在编译期间，通过sizeof(struct Person_IMPL)确定，Person_IMPL是一个结构体
	struct Person_IMPL {
		struct NSObject_IMPL NSObject_IVARS;
		int father_var_loves;
		NSInteger _height;
		NSInteger _weight;
	};
	通过sizeof的计算就能在编译阶段初步得到当前类所需内存大小，比如上面在32位系统就等于 4 + 4 + 4 + 4 = 16 字节
	
	3. 然而对象大小不仅仅包括自身属性所占用内存大小，还需要包括它父类属性，祖父类等等属性所占用内存大小。
	然而在编译static struct _class_ro_t _OBJC_CLASS_RO_$_Person __attribute__ ((used, section ("__DATA,__objc_const"))) = {时
	还没法获知其父类的属性大小信息，故这只能延迟到runtime初始化（或者运行时）的时候处理
		
		1. runtime初始化时候处理的是非懒加载的类（带+load方法的类），通过realizeClass进行
		2. 运行时的时候处理的是懒加载的类（运行时，首次通过objc_getClass("NSObject")方式获取时），通过realizeClass进行
			
			此时编译期间的类_class_t 已经在runtime初始化过程中（map_images -> _read_images -> readClass -> addNamedClass）
			插入到了一个gdb_objc_realized_classes列表中
			在objc_getClass("NSObject")获取到Class后会判断Class是否已经是realized，没有的话则进行realizeClass
			realizeClass 的目的是调整ro->instanceStart 和 _ro->instanceSize 以及 ro->ivars 中的偏移量
		3. 运行期间所有的类都是通过objc_getClass("xxx")获取，比如
		
			Person *p1 = [[Person alloc] init]; 会变成如下方式
		
			Person *p1 = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("Person"), 
			sel_registerName("alloc")), sel_registerName("init"));
			
		
		
	在map_images -> _read_images -> realizeClass 阶段，通过reconcileInstanceVariables 调整类的
	ro->instanceStart 和 _ro->instanceSize 以及 ro->ivars 中的偏移量（这便宜量需要包括父类instancesize） 
	
	顺带说一下的就是map_images所做的事情主要就是：
	a. 读取mach -o 中的“__objc_classlist”section中的类信息放到一个
	类（Class）列表中
	b. 调整类的内存布局，instancesize，ro->ivars各变量的偏移量
	c. 通过methodizeClass 将分类的方法添加到类列表methods的前面
		
		因为变量分类时是倒序遍历的，所以越是后编译的方法会越在方法列表前面
		编译顺序 Category_A[func1, func2, func3] -> Category_B[func1, func2, func3] -> Category_C[func1, func2, func3]
		最终能的类方法列表中是：
		【 Category_C[func1, func2, func3]，Category_B[func1, func2, func3]，Category_A[func1, func2, func3] ，本类方法 】
		
	
	
	```


* iOS内存分堆区，栈区，全局区（未初始化的全局变量区又叫BBS区），常量区（存放常量字符串），还有代码区。这些区内存的分配只有堆内存由程序员自己管理申请释放，其他区的内存分配管理是由编译器处理。
* 堆内存由程序员通过内存申请接口(alloc)申请，用完后通过内存释放接口(free)释放。然而一块堆内存可能有多个对象持有使用访问，为了记录当前内存块有多少对象引用，苹果使用了引用计数的方式来记录有几个对象持有同一块内存，当引用计数为0的时候，系统就会释放该内存（通常是在引用计数减一的时候判断需不需要释放内存）。
* 引用计数的管理由retain(加一)，release(减一) 接口进行管理，当用release接口对引用计数器进行减一操作后，判断如果减后的值<= 0，则发送一条SEL_dealloc消息，dealloc 最终在object_dispose中调用free 释放内存