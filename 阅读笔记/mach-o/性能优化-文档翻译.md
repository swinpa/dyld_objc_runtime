#文档翻译
##性能优化[Apple文档](https://developer.apple.com/documentation/xcode/making-changes-to-reduce-memory-use)

* 性能优化是比较大的一个话题，包括了好多方面，比如，启动优化，卡顿优化，内存优化，
   电池耗电优化(主要是由于CPU、GPU、网络等因素决定)，包体积优化，
   
   每一方面又包括了如何去检测，行业上又有哪些手段检测，最终如何去优化等

###内存

#####为什么要做内存优化？
* 内存是有限的，当我们的应用占用的内存太大，在内存吃紧的时候会被系统强啥掉(这就是我们熟知的jetsam事件)

1. 收集内存使用信息
	
	线下可以通过instrument 中的Allocation工具查看
	
	线上可以使用
		
		1. OOMDetector
		2. FBAllocationTraker
                swizzle NSObject 的 +alloc 和 -dealloc 方法，它只支持监听 Objective-C 的对象，不支持 C++/C 在堆上操作的对象
		3. Matrix
	[Matrix](https://cloud.tencent.com/developer/inventory/6249/article/1483621)
	
	
	
	内存泄漏检测

	1. 第一种查询方式：Analyze 静态分析 （command ＋ shift ＋ b）也就是编译，主要分析以下四种问题：
	
		* 逻辑错误：访问空指针或未初始化的变量等；
		* 内存管理错误：如内存泄漏等；
		* 声明错误：从未使用过的变量；
		* Api调用错误：未包含使用的库和框架。
	
	2. 第二种查询方式：Instruments中的Leak动态分析内存泄漏，product－>profile －>leaks 打开工具主窗口

	
2. 如何减少内存使用
	
	```
	通过减少过度使用的内存
	1. Optimize Image Assets(优化图片资源)
	   大图，特别是high color depths的图片会占用很大的内存，
	   
	   		a. 通过图片裁减把图片裁减成它展示的尺寸大小来进行优化
	   		b. 使用 Image I/O 将从网络(或用户图库)加载的图片转为适当的scale 跟color depth，可以减少内存使用
	
	2. Reduce the Size of Core Data Transactions(减小Core Data 的事务大小)
	   Core Data 将 NSManagedObject 实例的更改存储在内存中，直到 NSManagedObjectContext 被保存，
	   在更改进入持久存储之前，它们一直驻留在内存中，因此您的应用程序在保存之间的时间越长，Core Data 
	   占用内存越大。 相反，您的应用保存得越频繁，它对设备固态驱动器的写入就越多，这会影响性能并增加
	   驱动器的磨损。 设计您的应用程序的持久性模型以在这两个资源约束之间取得平衡。
	
	3. Discard Unused View Objects（释放未用到的view对象）
	   当用户锁屏了(或者你的APP退到后台了)不在看你的APP时，没有必要再持有图片，视频或者其他资源
	
	4. Eliminate Memory Leaks（剔除内存泄漏）
	5. Remove References to Unused Objects
	   比如一些列表，如果列表很长很长，那当用户滚动后不再显示，那这些列表的内容应该清理释放掉
	6. 
	
	```
3. 如何防止内存使用复原（重现的意思？又出现内存使用问题？）
4. Responding to Low-Memory Warnings
	
	```
	If your app loads data it can easily recreate, consider using NSPurgeableData. When the contents 
	of NSPurgeableData aren’t marked as in-use through beginContentAccess(), the system automatically 
	discards the contents in low-memory situations. This automatic discard process helps your app react 
	to a low-memory warnings more quickly, because the kernel handles discarding the data, rather than 
	your app, which is waiting to receive the low-memory notification before discarding the data.
	
	如果加载的数据是很容易create的，那么考虑使用NSPurgeableData，NSPurgeableData类型的数据，如果没通过
	beginContentAccess()将数据标志为正在使用时，如果收到内存告警时，这部分数据会被自动回收释放
	
	```
	```
	收到内存告警时要及时释放内存
	1. 使用NSCache做缓存，因为NSCache在收到内存告警时会自动释放内存
	
	2. 在收到告警时，千万不能通过遍历的方式查询需要释放的内存，因为iOS 会压缩应用程序最近未访问的内存页面，
	   一旦你遍历查找，那压缩的内存会重新解压出来，增加系统的内存负担
	3. 
	
	```

####[参考大佬的文章](https://juejin.cn/post/6844904119723884551)
####1、降低图片解码和渲染开销

* 将图片渲染显示在屏幕上，需要先将其解码成位图；而位图大小：像素高 * 像素宽 * 4字节(4字节对应一个像素点，4个通道的大小)；
图片解码会造成内存使用上升，尤其是高分辨率图解码可能导致内存暴涨；
* 代码优化建议：


	* 善待"大"图（位图大小大于60MB）解码：将原图裁剪成多个小图，然后依次绘制到目标位图context中，具体可见SDWebImage中和关于**decodedAndScaledDownImageWithImage:**的实现；


	* 限制并发解码图片的个数；

		* 图片大小调整和显示大小一样，以此避免重采样(重采样也很消耗资源，放大图像称为上采样/插值（upsamping），缩小图像为小采样（downsampling));
		* 使用 ImageIO直接读取图像大小和元数据信息，减少内存开销。
		* iOS10后使用 UIGraphicsImageRenderer 创建 image 上下文，而不是UIGraphicsBeginImageContextWithOptions，因为前者的性能更好、更高效，并且支持广色域；


####2、其他降低内存峰值办法

* 合理使用autorealsepool，降低内存峰值，避免 OOM

	* 基于引用计数,Pool执行drain方法会release所有该Pool中的autorelease对象
	* 可以嵌套多个AutoReleasePool
	* 每个线程并没有设置默认的AutoReleasePool,需要手动创建,避免内存泄露
	* 在一段内存分配频繁的代码中嵌套AutoReleasePool有利于降低整体内存峰值



* 复用大内存对象，如UITableViewCell对象；懒加载大的内存对象


* imageNamed 和 imageWithContentOfFile 的选择

	* imageNamed使用系统缓存，适用于频繁使用的小图片
	* imageWithContentOfFile不带缓存机制,适用于大图片,使用完就释放



* 建议NSData读取文件方式

	* 建议使用[NSData dataWithContentsOfFile:path options:NSDataReadingMappedIfSafe error:&error];
	* 该API映射文件到虚拟内存, 只有读取操作的时候才会读取相应页的内容到物理内存页中；



* 用 NSCache 代替 NSMutableDictionary， 因为 NSCache 可以自动清理内存，在内存吃紧的时候会更加合理。

	* NSCache有2种界限条件:totalCostLimt & countLimit，超过这两种界限后系统会去释放一些旧的资源.
	* 监听到内存警告消息后移除所有Cache



* 使用 NSPurgableData 代替NSData，主要原因如下：

	* 当系统处于低内存的时候会自动移除
	* 适用于大数据



* 栈内存分配：alloca(size_t)

	* 栈分配仅仅修改栈指针寄存器，比malloc遍历并修改空闲列表要快得多
	* 栈内存一般都已经在物理内存中，不用担心页错误
	* 函数返回的时候栈分配的空间都会自动释放
	* 但仅适合小空间的分配,并且函数嵌套不宜过深



* 堆内存分配：calloc VS malloc + memset

	* calloc(size_t num,size_t size)分配内存时是虚拟内存，只有在访问的时候才会发生物理页的映射关系；
	* malloc + memset 会产生Dirty Memory
	* calloc函数得到的内存空间是经过初始化的，其内容全为0，而malloc函数得到的内存空间是未初始化的，必须使用memset函数来初始化；

###3、避免循环引用，减少内存泄露



* 代码优化建议

	* 申明代理(delegate)为weak；
	* 使用 weak strong dance 来解决 block 中的循环引用问题；
	* 实现NSProxy(虚拟类)的子类，然后在子类中定义weak修饰的target，然后实现消息转发方法，使target处理业务逻辑；一般用于解决NSTimer、CADisplayLink的循环引用；
	* CoreFoundation对象、CoreGraphics对象、还有C/C++的内存分配需要管理好，有malloc就要有free


* 善用工具：MLeaksFinder + Instrument 或 FBMemoryProfiler + Instrument组合使用。通过MLeaksFinder/FBMemoryProfiler发现后。然后使用Instrument再验证；

* 工具检测OOM：

	OOM判断主要依赖于排除法，在应用启动的时候通过排查法判断上次应用退出的原因
	
		1.App没有升级
		2.App没有调用exit()或abort()退出
		3.App没有出现crash
		4.用户没有强退App
		5.系统没有升级/重启
		6.App当时没有后台运行
		7.App出现FOOM
		
	排除法可能会出现误判的可能比如：
		
		1. 崩溃没被捕获的情况
		2. 前台卡死引起系统watchdog强杀

7.App出现FOOM
	
	[OOMDetector](https://segmentfault.com/a/1190000012825286)
		
		手Q开源的方案
		
		通过hook IOS系统底层内存分配的相关方法（包括malloc_zone相关的堆内存分配以及
		vm_allocate对应的VM内存分配方法），跟踪并记录进程中每个对象内存的分配信息，
		包括分配堆栈、累计分配次数、累计分配内存等，这些信息也会被缓存到进程内存中。
		在内存触顶的时候，组件会定时Dump这些堆栈信息到本地磁盘，这样如果程序爆内存了，
		就可以将爆内存前Dump的堆栈数据上报到后台服务器进行分析。
	
	Allocation
		
		苹果官方提供的Allocation内存分析工具，在开发调试阶段，可以用Allocation详细分析App
		各模块内存占用。Allocation对App的内存监控比较全面，能监控到所有堆内存以及部分VM
		内存分配。虽然Allocation的功能比较强大，但是它也有比较明显的使用局限性，
		主要表现为以下两点：

			1. 无法独立在App运行，只能在调试阶段连接Mac使用
			2. 性能较差，大型App开启后容易引发卡死
	
	FBAllocationTracker
		
		facebook开源方案，通过Method Swizzling替换原本的alloc方法，记录所有OC实例的分配
		信息，帮助App在运行阶段发现一些OC对象的异常增长问题
		
		1. 监控范围不够全面，只能监控OC对象，不能监控C++对象和malloc内存块以及VM内存
		2. 没有内存对象分配的堆栈信息，对于开发者来说很难只通过对象的类型和数量定位到内存
		   增长的原因
	[Matrix](https://cloud.tencent.com/developer/inventory/6249/article/1427932)
		
		微信开源的方案
	
		 通过设置libmalloc中的malloc_logger和__syscall_logger函数指针，从而达到在我们开发所
		 写的代码层面捕获malloc/free/realloc/vm_allocate/vm_deallocate等所有的内存分配/释
		 放函数的信息，这也是内存调试工具malloc stack的实现原理。有了这些信息，我们是可以
		 轻易的记录内存的分配大小、分配堆栈，分配堆栈可以用backtrace函数捕获，但捕获到的
		 地址是虚拟内存地址，不能从符号表dsym解析符号。所以还要记录每个image加载时的偏移
		 slide，这样符号表地址=堆栈地址-slide。

####内存方面文章
[](https://juejin.cn/post/6844903621276991502#heading-3)
[iOS内存二三事](https://juejin.cn/post/6844904119723884551)
[深入了解iOS中的OOM(低内存崩溃)](https://blog.csdn.net/TuGeLe/article/details/104004692)
[iOS 性能优化实践：头条抖音如何实现 OOM 崩溃率下降50%+](https://juejin.cn/post/6885144933997494280)


