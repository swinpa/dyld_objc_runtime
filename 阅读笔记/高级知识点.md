#知识点
####[操作UI为什么必须在主线程或者main dispatch queue？](https://juejin.cn/post/6993979457996324894)
1.   因为UI是直接跟用户交互的，所以对UIKit的性能要求特别高，所以在UIKit的设计上不使用锁来保障UIKit的读写访问安全，没有加锁，又要保障UIKit的读写访问安全，那么就必然要在main dispatch queue（串行队列）中


####野指针[参考](https://juejin.cn/post/6930979515552235528) [官方文档](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html)	
	1. 检测方案
		1. Malloc Scribble 
			1. 原理：在对象释放时，在对象的内存上填充0x55，当通过指针再次访问时就出现必崩的现象
			2. 缺点：内存被重新分配给其他对象时，会有意想不到的问题****
		2. Zombie Objects（僵尸对象）
			1.原理：在Dealloc 中不调用free()去释放内存，而且动态创建一个类，
			  将对象的ISA指向新类
			2.缺点： 内存没释放，久而久之，内存会积累的原来越多，
			  所以需要用一定策略定时去释放部分

####内存leaks 检测[参考1](http://hchong.net/2020/03/11/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%9F%A5-%E5%8E%9F%E7%90%86/)  [参考1](https://xibhe.com/2019/05/27/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/)
	1. 检测步骤
		1. Analyzer（静态分析）
		2. MLeaksFinder (第三方工具)
		3. Instruments Leaks (动态检测)
	2. 第三方工具原理
		1. MLeaksFinder
			1. 原理：巧用weak特性，在获知对象准备释放的时候，通过一个weak指针
			   指向对象，然后延后一段时间检查这个weak指针是否为nil 
			   
			   这里可以引申出weak指针特性的一些巧用，如我们自己项目中，用weak指针指向评分引导页面
			   来检测评分引导页面是否已经关闭
		2. 其他看参考文章

####性能优化

* 影响性能
	
	```
	1. 主线程在跑耗时方法，GPU 渲染耗时
	2. 频繁进行耗时io操作
	3. 线程太多，CPU太高，导致主线程CPU低
	4. 内存太高
	5. 主线程是用来处理用户交互的，应尽量避免把耗时的操作放到主线程上
	```

* 检测方案
	
	```
	1. fps:
		使用CADisplayLink,计算1秒内回调多少次即刻得到帧率信息，如果帧率小于某个阈值，
		则认为是一次卡顿
	2. runloop:
		向主线程的runloop 添加一个observe，监听主线程runloop的kCFRunLoopBeforeSources，kCFRunLoopAfterWaiting 
		这来两个事件之间的时间间隔，如果超过一个阈值则就认为是卡顿
		
			微信的Matrix 卡顿监控在 Runloop 的起始最开始和结束最末尾位置添加 Observer，
			从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，
			当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。
		
		存在的问题：
			主线程的RunLoop在闲置时基本处于Before Waiting状态，这就导致了即便没有发生任何卡顿，
			这种检测方式也总能认定主线程处在卡顿状态。
	
	3. ping:
		创建一个子线程进行循环检测，每次检测时设置标记位为YES，然后派发任务到主线程中将标记位设置为NO。
		接着子线程沉睡超时阙值时长，当子线程睡眠返回时判断标志位是否被主线程成功设置成NO，如果没有说明主线程发生了卡顿。
	
	```
	```
	dispatch_async(__lsl_fluecy_monitor_queue(), ^{
        while (lsl_is_monitoring) {
            __block BOOL timeOut = YES;
            dispatch_async(dispatch_get_main_queue(), ^{
                timeOut = NO;
                dispatch_semaphore_signal(lsl_semaphore);
            });
            [NSThread sleepForTimeInterval: lsl_time_out_interval];
            if (timeOut) {
            	  //主线程卡顿
            }
            dispatch_wait(lsl_semaphore, DISPATCH_TIME_FOREVER);
        }
    });
	```
* 检测CPU可以
* 检测到卡顿后将所有线程的调用栈dump下来，上报，后续分析
