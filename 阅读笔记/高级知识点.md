#知识点
####[操作UI为什么必须在主线程或者main dispatch queue？](https://juejin.cn/post/6993979457996324894)

1. 渲染时机

	Core Animation在主线程的RunLoop中注册监听了before source事件，在收到该事件时对应的回
	调接口遍历存放了所有需要重新渲染的UIView，CALayer的容器，执行CALayer的display进行渲染操
	作。所以说UI的渲染是在主线程中进行的。
2. 子线程操作UI对性能的影响

	1. UI操作，最终需要将需要更新的UI标志为dirty并放入到Core Animation可以访问到的容器中，这样Core 
	Animation 才能获取到对其执行渲染操作。如果UI的更新操作是在子线程进行，那么访问容器时必定需要
	进行加锁来保证容器的读写访问安全。这样一来一旦子线程数量多了，加解锁，线程上下文切换会带来一
	定的性能消耗
	2. UI操作，对Core Animation来说是一个未知的事件，由程序员来加锁保证访问安全太过复杂了
3. 因为UI是直接跟用户交互的，所以对UIKit的性能要求特别高，所以在UIKit的设计上不使用锁来保障UIKit的读写访问安全，没有加锁，又要保障UIKit的读写访问安全，那么就必然要在main dispatch queue（串行队列）中
4. [Texture的异步渲染和布局引擎](https://juejin.cn/post/6844904114703302670)

	在该文章中也提到了视图的渲染机制
	
	```
	CALayer的display方法由系统调用，用来更新layer的内容，如果layer有delegate对象，那么display方法将尝试调用delegate的displayLayer:
	方法来更新layer的内容。如果delegate没有实现displayLayer:方法，则这个方法会创建一个backing store来保存原来的内容，然后调用layer
	的drawInContext:方法来填充back store（在drawInContext中又会调用delegate的- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;方法
	填充context）。最后以新的backing store替换layer的先前内容达到更新layer的目的。通常UIKit中CALayer的
	delegate是UIView对象。有两种方式来自定义CALayer的内容，一种是直接设置CALayer的contents属性来创建寄宿图；另一种是通过实现
	CALayer的delegate方法，可以用于直接对CALayer进行操作。
	
	
	/* Reload the content of this layer. Calls the -drawInContext: method
	 * then updates the `contents' property of the layer. Typically this is
	 * not called directly. */
	- (void)display;


	/* Called via the -display method when the `contents' property is being
	 * updated. Default implementation does nothing. The context may be
	 * clipped to protect valid layer content. Subclasses that wish to find
	 * the actual region to draw can call CGContextGetClipBoundingBox(). */
	
	- (void)drawInContext:(CGContextRef)ctx;
	
	```
	
	```
	If defined, called by the default implementation of the -display method, in which case it should implement the entire display
	process (typically by setting the “contents” property).
	- (void)displayLayer:(CALayer *)layer;
	也就是代理在实现displayLayer方法中设置content属性的值
	
	/* If defined, called by the default implementation of -drawInContext: */
	- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
	
	```
	
	触发display的时机
	
	```
	
	Runloop任务分发 ->CoreAnimation
	CA在Runloop中注册了一个Observer，监听了BeforeWaiting和Exit事件，优先级低于其他Observer。当一个触摸事件到来时，Runloop被唤
	醒，App中的代码会执行一些操作，比如创建和调整视图层级、设置UIView的frame、修改CALayer的透明度、为视图添加一个动画；这些操作
	最终会被CALayer捕获，并通过CATransaction提交到一个中间状态去。当上面的所有操作结束后，Runloop即将进入休眠(或者退出)时，关注
	该事件的Observer都会得到通知。这时CA注册的Observer就会在回调中，把所有的中间状态合并提交到GPU去显示；如果此处有动画，CA会
	通过CADisplayLink等机制多次触发相关流程。

	```


####野指针[参考](https://juejin.cn/post/6930979515552235528) [官方文档](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html)	
[官方文档](https://developer.apple.com/documentation/xcode/understanding-the-exception-types-in-a-crash-report)
[jetsam官方文档](https://developer.apple.com/documentation/xcode/identifying-high-memory-use-with-jetsam-event-reports)
	

[关于Malloc Scribble and Zombie Objects](https://juejin.cn/post/6968700344050122766)
    
1. 检测方案

	1. Malloc Scribble 
		1. 原理：在对象释放时，在对象的内存上填充0x55，当通过指针再次访问时就出现必崩的现象（其官方解释如下：申请内存 alloc 时在内存上填0xAA，
			     释放内存 dealloc 在内存上填 0x55）
			     [官方文档](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html)
		2. 缺点：内存被重新分配给其他对象时，会有意想不到的问题****
		
	2. Zombie Objects（僵尸对象）类似KVO的ISA swizzling [官方文档](https://developer.apple.com/documentation/xcode/investigating-crashes-for-zombie-objects?preferredLanguage=occ)
	
		1.原理：在Dealloc 中不调用free()去释放内存，而且动态创建一个类，
			  将对象的ISA指向新类_NSZombie_People
                
            通过hook dealloc方法，底层代码注释有说明
            // Replaced by NSZombies
            - (void)dealloc {
                _objc_rootDealloc(self);
            }
		2.缺点： 内存没释放，久而久之，内存会积累的原来越多，
			  所以需要用一定策略定时去释放部分

####内存leaks 检测[参考1](http://hchong.net/2020/03/11/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%9F%A5-%E5%8E%9F%E7%90%86/)  [参考1](https://xibhe.com/2019/05/27/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/)
	1. 检测步骤
		1. Analyzer（静态分析）
		2. MLeaksFinder (第三方工具)
		3. Instruments Leaks (动态检测)
	2. 第三方工具原理
		1. MLeaksFinder
			1. 原理：巧用weak特性，在获知对象准备释放的时候，通过一个weak指针
			   指向对象，然后延后一段时间检查这个weak指针是否为nil 
			   
			   这里可以引申出weak指针特性的一些巧用，如我们自己项目中，用weak指针指向评分引导页面
			   来检测评分引导页面是否已经关闭
		2. 其他看参考文章

####性能优化

* 影响性能
	
	```
	1. 主线程在跑耗时方法，GPU 渲染耗时
	2. 频繁进行耗时io操作
	3. 线程太多，CPU太高，导致主线程CPU低
	4. 内存太高
	5. 主线程是用来处理用户交互的，应尽量避免把耗时的操作放到主线程上
	```

* 检测方案
	
	```
	1. fps:
		使用CADisplayLink,计算1秒内回调多少次即可得到帧率信息，如果帧率小于某个阈值，
		则认为是一次卡顿
	2. runloop:
		向主线程的runloop 添加一个observe，监听主线程runloop的kCFRunLoopBeforeSources，kCFRunLoopAfterWaiting 
		这来两个事件之间的时间间隔，如果超过一个阈值则就认为是卡顿
		
			微信的Matrix 卡顿监控在 Runloop 的起始最开始和结束最末尾位置添加 Observer，
			从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，
			当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。
		
		存在的问题：
			主线程的RunLoop在闲置时基本处于After Waiting状态，这就导致了即便没有发生任何卡顿，
			这种检测方式也总能认定主线程处在卡顿状态。
		为什么检测这两个事件可以认为是卡顿？？？？
			一轮RunLoop下来主要做的事情：
			
			1. 通知Observer：将要处理Timer
			2. 通知Observer：将要处理Source0
			3. 处理Source0
			4. 如果有Source1，跳到第8步（通过mach_msg接口从内核读取Source1事件）
			5. 通知Observer：线程即将休眠
				在阶段5会进行视图渲染准备
			6. 休眠，等待唤醒
			7. 通知Observer：线程刚被唤醒
			8. 处理唤醒时收到的消息之后跳回1

			
			1. 应用启动时Core Animation 会在主线程的RunLoop中注册一个Observer监听RunLoop的BeforeWaiting(即将进入休眠)和Exit(即将退出Loop)事件。
            2. 当收到这两个事件时，会回调去执行一个很长的函数： _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。
                在这个函数中会遍历所有待处理的UIView/CAlayer（保存在一个全局的容器）以执行实际的绘制和更新UI（CPU，GPU渲染）。
            3.  当UI发生变更时（比如Frame变了 、UIView/CALayer层次变了(addSubview,removeSubview))，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。
            
                /*
                Invalidates the current layout of the receiver and triggers a layout update 
                during the next update cycle.
                */
                [self.view setNeedsLayout];//
                
                /*
                Lays out the subviews immediately, if layout updates are pending.
                */
                [self.view layoutIfNeeded];
            4. 当RunLoop的BeforeWaiting事件到来时，在回调函数中会遍历全局容器中的UIView/CALayer（已标记为dirty），并调用CALayer的display方法进入到真正的绘制当中(主要就是通过异步绘制或者系统绘制流程等到layer.content)。

            	
            所以可以认为主线程的一轮RunLoop做的所有事情主要发生在kCFRunLoopBeforeSources，kCFRunLoopBeforeWaiting
            之间

            
			
	
	3. ping:
		创建一个子线程进行循环检测，每次检测时设置标记位为YES，然后派发任务到主线程中将标记位设置为NO。
		接着子线程沉睡超时阙值时长，当子线程睡眠返回时判断标志位是否被主线程成功设置成NO，如果没有说明主线程发生了卡顿。
		
		简单点说就是在子线程上设置一个标志为，然后
	
	```
	```
	dispatch_async(__lsl_fluecy_monitor_queue(), ^{
        while (lsl_is_monitoring) {
            __block BOOL timeOut = YES;
            dispatch_async(dispatch_get_main_queue(), ^{
                timeOut = NO;
                dispatch_semaphore_signal(lsl_semaphore);
            });
            [NSThread sleepForTimeInterval: lsl_time_out_interval];
            if (timeOut) {
            	  //主线程卡顿
            }
            dispatch_wait(lsl_semaphore, DISPATCH_TIME_FOREVER);
        }
    });
	```
* 检测CPU可以
* 检测到卡顿后将所有线程的调用栈dump下来，上报，后续分析

* [CALayer 绘制逻辑](https://cloud.tencent.com/developer/article/2080845)
