#知识点

####野指针[参考](https://juejin.cn/post/6930979515552235528)	
	1. 检测方案
		1. Malloc Scribble 
			1. 原理：在对象释放时，在对象的内存上填充0x55
			2. 缺点：内存被重新分配给其他对象时，会有意想不到的问题
		2. Zombie Objects（僵尸对象）
			1.原理：在Dealloc 中不调用free()去释放内存，而且动态创建一个类，
			  将对象的ISA指向新类
			2.缺点： 内存没释放，久而久之，内存会积累的原来越多，
			  所以需要用一定策略定时去释放部分

####内存leaks 检测[参考1](http://hchong.net/2020/03/11/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%9F%A5-%E5%8E%9F%E7%90%86/)  [参考1](https://xibhe.com/2019/05/27/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/)
	1. 检测步骤
		1. Analyzer（静态分析）
		2. MLeaksFinder (第三方工具)
		3. Instruments Leaks (动态检测)
	2. 第三方工具原理
		1. MLeaksFinder
			1. 原理：巧用weak特性，在获知对象准备释放的时候，通过一个weak指针
			   指向对象，然后延后一段时间检查这个weak指针是否为nil 
			   
			   这里可以引申出weak指针特性的一些巧用，如我们自己项目中，用weak指针指向评分引导页面
			   来检测评分引导页面是否已经关闭
		2. 其他看参考文章

####性能优化

* 影响性能
	
	```
	1. 主线程在跑耗时方法，GPU 渲染耗时
	2. 频繁进行耗时io操作
	3. 线程太多，CPU太高，导致主线程CPU低
	4. 内存太高
	```

* 检测方案
	
	```
	1. fps:
		使用CADisplayLink,计算1秒内回调多少次即刻得到帧率信息，如果帧率小于某个阈值，
		则认为是一次卡顿
	2. runloop:
		向主线程的runloop 添加一个observe，监听主线程runloop的beforeSource，beforeWaiting 
		这来两个事件之间的时间间隔，如果超过一个阈值则就认为是卡顿，
	```
* 检测CPU可以
* 检测到卡顿后将所有线程的调用栈dump下来，上报，后续分析
