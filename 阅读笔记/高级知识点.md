#知识点
####[操作UI为什么必须在主线程或者main dispatch queue？](https://juejin.cn/post/6993979457996324894)

1. 渲染时机

	Core Animation在主线程的RunLoop中注册监听了before source事件，在收到该事件时对应的回
	调接口遍历存放了所有需要重新渲染的UIView，CALayer的容器，执行CALayer的display进行渲染操
	作。所以说UI的渲染是在主线程中进行的。
2. 子线程操作UI对性能的影响

	1. UI操作，最终需要将需要更新的UI标志为dirty并放入到Core Animation可以访问到的容器中，这样Core 
	Animation 才能获取到对其执行渲染操作。如果UI的更新操作是在子线程进行，那么访问容器时必定需要
	进行加锁来保证容器的读写访问安全。这样一来一旦子线程数量多了，加解锁，线程上下文切换会带来一
	定的性能消耗
	2. UI操作，对Core Animation来说是一个未知的事件，由程序员来加锁保证访问安全太过复杂了
3. 因为UI是直接跟用户交互的，所以对UIKit的性能要求特别高，所以在UIKit的设计上不使用锁来保障UIKit的读写访问安全，没有加锁，又要保障UIKit的读写访问安全，那么就必然要在main dispatch queue（串行队列）中



####野指针[参考](https://juejin.cn/post/6930979515552235528) [官方文档](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html)	
	1. 检测方案
		1. Malloc Scribble 
			1. 原理：在对象释放时，在对象的内存上填充0x55，当通过指针再次访问时就出现必崩的现象
			2. 缺点：内存被重新分配给其他对象时，会有意想不到的问题****
		2. Zombie Objects（僵尸对象）
			1.原理：在Dealloc 中不调用free()去释放内存，而且动态创建一个类，
			  将对象的ISA指向新类
			2.缺点： 内存没释放，久而久之，内存会积累的原来越多，
			  所以需要用一定策略定时去释放部分

####内存leaks 检测[参考1](http://hchong.net/2020/03/11/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%9F%A5-%E5%8E%9F%E7%90%86/)  [参考1](https://xibhe.com/2019/05/27/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/)
	1. 检测步骤
		1. Analyzer（静态分析）
		2. MLeaksFinder (第三方工具)
		3. Instruments Leaks (动态检测)
	2. 第三方工具原理
		1. MLeaksFinder
			1. 原理：巧用weak特性，在获知对象准备释放的时候，通过一个weak指针
			   指向对象，然后延后一段时间检查这个weak指针是否为nil 
			   
			   这里可以引申出weak指针特性的一些巧用，如我们自己项目中，用weak指针指向评分引导页面
			   来检测评分引导页面是否已经关闭
		2. 其他看参考文章

####性能优化

* 影响性能
	
	```
	1. 主线程在跑耗时方法，GPU 渲染耗时
	2. 频繁进行耗时io操作
	3. 线程太多，CPU太高，导致主线程CPU低
	4. 内存太高
	5. 主线程是用来处理用户交互的，应尽量避免把耗时的操作放到主线程上
	```

* 检测方案
	
	```
	1. fps:
		使用CADisplayLink,计算1秒内回调多少次即刻得到帧率信息，如果帧率小于某个阈值，
		则认为是一次卡顿
	2. runloop:
		向主线程的runloop 添加一个observe，监听主线程runloop的kCFRunLoopBeforeSources，kCFRunLoopBeforeWaiting 
		这来两个事件之间的时间间隔，如果超过一个阈值则就认为是卡顿
		
			微信的Matrix 卡顿监控在 Runloop 的起始最开始和结束最末尾位置添加 Observer，
			从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，
			当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。
		
		存在的问题：
			主线程的RunLoop在闲置时基本处于Before Waiting状态，这就导致了即便没有发生任何卡顿，
			这种检测方式也总能认定主线程处在卡顿状态。
		为什么检测这两个事件可以认为是卡顿？？？？
			一轮RunLoop下来主要做的事情：
			
			1. 通知Observer：将要处理Timer
			2. 通知Observer：将要处理Source0
			3. 处理Source0
			4. 如果有Source1，跳到第8步（通过mach_msg接口从内核读取Source1事件）
			5. 通知Observer：线程即将休眠
				在5这个阶段会进行视图渲染准备
			6. 休眠，等待唤醒
			7. 通知Observer：线程刚被唤醒
			8. 处理唤醒时收到的消息之后跳回1

			
			1. 应用启动时Core Animation 会在主线程的RunLoop中注册一个Observer监听RunLoop的BeforeWaiting(即将进入休眠)和Exit(即将退出Loop)事件。
            2. 当收到这两个事件时，会回调去执行一个很长的函数： _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。
                在这个函数中会遍历所有待处理的UIView/CAlayer（保存在一个全局的容器）以执行实际的绘制和更新UI（CPU，GPU渲染）。
            3.  当UI发生变更时（比如Frame变了 、UIView/CALayer层次变了(addSubview,removeSubview))，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。
            4. 当RunLoop的BeforeWaiting事件到来时，在回调函数中会遍历全局容器中的UIView/CALayer（已标记为dirty），并调用CALayer的display方法进入到真正的绘制当中(主要就是通过异步绘制或者系统绘制流程等到layer.content)。

            	
            所以可以认为主线程的一轮RunLoop做的所有事情主要发生在kCFRunLoopBeforeSources，kCFRunLoopBeforeWaiting
            之间

            
			
	
	3. ping:
		创建一个子线程进行循环检测，每次检测时设置标记位为YES，然后派发任务到主线程中将标记位设置为NO。
		接着子线程沉睡超时阙值时长，当子线程睡眠返回时判断标志位是否被主线程成功设置成NO，如果没有说明主线程发生了卡顿。
		
		简单点说就是在子线程上设置一个标志为，然后
	
	```
	```
	dispatch_async(__lsl_fluecy_monitor_queue(), ^{
        while (lsl_is_monitoring) {
            __block BOOL timeOut = YES;
            dispatch_async(dispatch_get_main_queue(), ^{
                timeOut = NO;
                dispatch_semaphore_signal(lsl_semaphore);
            });
            [NSThread sleepForTimeInterval: lsl_time_out_interval];
            if (timeOut) {
            	  //主线程卡顿
            }
            dispatch_wait(lsl_semaphore, DISPATCH_TIME_FOREVER);
        }
    });
	```
* 检测CPU可以
* 检测到卡顿后将所有线程的调用栈dump下来，上报，后续分析

* [CALayer 绘制逻辑](https://cloud.tencent.com/developer/article/2080845)
