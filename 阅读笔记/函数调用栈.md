###函数调用栈
[一文读懂iOS线程调用栈原理](https://blog.csdn.net/henry_lei/article/details/109625533?spm=1001.2014.3001.5502)
```
#include "stdio.h"
int add(int a, int b)
{
    int c = a + b;
    printf("%d", c);
    return c;
}
int main(int argc, char * argv[]) {
    int a = 4;
    int b = 6;
    int c = add(a, b);
    return 0;
}
```

#### 栈帧

* 在栈中保存了每个函数的参数，函数内部的临时变量，还保存了函数的返回地址（也就是调用函数要执行的下一个指令地址）
* 每个函数，在整个栈中都有一部分属于它的区域，这部分属于函数的就简称为栈帧

####相关的寄存器




* sp：Stack Pointer，保存栈顶地址。
* x29(fp)：Frame pointer，保存栈底地址。
	
	Stack Pointer指向栈顶部，Frame Pointer指向上一个栈帧的Stack Pointer值，通过Frame Pointer就可以递归回溯获取整个调用栈。

* x30(lr)：Link Register，保存子函数结束后需要执行的下一条指令地址。
* x0~x7(w0~w7)：调用子函数时存放参数数据，然后子函数结束后一般把返回值存放在x0。


1. 上面的代码中，main函数调用了add函数，在调用前，需要把add函数的参数存放到寄存器中（w0和w1）。然后再调用add函数。
2. 调用add函数时，系统会为add函数新建一帧（fp_add~sp_add），用于存储它的内部变量，同时保存main函数的fp和lr寄存器，用于add函数执行完后恢复main函数的栈帧。
3. add函数执行完成后，会恢复之前保存的fp和lr，系统会回到main函数刚才中断的地方继续往下执行。
4. 通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。

